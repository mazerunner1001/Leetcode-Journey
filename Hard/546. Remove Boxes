// 3d dp solution similar to strange printer but with more complexity (memoization due to complex dependencies) :
// *Both deal with segments of same values.
// *Both allow merging non-adjacent equal elements for benefit.
// *Both are interval DP problems where merging reduces cost (or increases reward).

// dp[i][j][k] = maximum points we can get from boxes[i..j] if there are k boxes of the same color as boxes[i] attached to its left.
// dp[i][i][k] = (k + 1) * (k + 1)
// dp[i][j][k] = (k+1)*(k+1) + dp[i+1][j][0]
// dp[i][j][k] = max(dp[i][j][k], dp[i+1][m-1][0] + dp[m][j][k+1])


class Solution {
public:
    int dp[100][100][100];
    int removeBoxes(vector<int>& boxes) {
        memset(dp, 0, sizeof(dp));
        return solve(boxes, 0, boxes.size()-1, 0);
    }

    int solve(vector<int>& boxes, int i, int j, int k) {
        if (i > j) return 0;
        if (dp[i][j][k] != 0) return dp[i][j][k];

        int res = (k+1)*(k+1) + solve(boxes, i+1, j, 0);

        for (int m = i+1; m <= j; m++) {
            if (boxes[m] == boxes[i]) {
                res = max(res, solve(boxes, i+1, m-1, 0) + solve(boxes, m, j, k+1));
            }
        }

        return dp[i][j][k] = res;
    }
};
