// freq calculation using Mo's algorithm, xor using fenwick trees

// https://www.hackerearth.com/problem/algorithm/mystixorama-26468c50/?update=google&purpose=login&source=list_view

#include <bits/stdc++.h>
using namespace std;

struct Query {
    int l, r, x, y, idx;
};

struct Fenwick {
    vector<long long> bit;
    int n;
    Fenwick(int n) : n(n), bit(n + 2, 0) {}
    void add(int i, long long val) {
        for (; i <= n; i += (i & -i)) bit[i] += val;
    }
    long long sum(int i) {
        long long s = 0;
        for (; i > 0; i -= (i & -i)) s += bit[i];
        return s;
    }
    long long rangeSum(int l, int r) {
        return sum(r) - sum(l - 1);
    }
};

const int MAXN = 1e5 + 5;
int A[MAXN];
unordered_map<int, int> freq;       // value -> frequency
unordered_map<int, long long> xorForFreq; // freq -> xor of all elements with that freq

void add(int val, Fenwick &bit, int maxFreq) {
    int oldF = freq[val];
    if (oldF > 0) {
        long long x = xorForFreq[oldF];
        bit.add(oldF, -x);
        xorForFreq[oldF] ^= val;
        bit.add(oldF, xorForFreq[oldF]);
    }
    freq[val]++;
    int newF = freq[val];
    long long x = xorForFreq[newF];
    bit.add(newF, -x);
    xorForFreq[newF] ^= val;
    bit.add(newF, xorForFreq[newF]);
}

void removeVal(int val, Fenwick &bit, int maxFreq) {
    int oldF = freq[val];
    long long x = xorForFreq[oldF];
    bit.add(oldF, -x);
    xorForFreq[oldF] ^= val;
    bit.add(oldF, xorForFreq[oldF]);
    freq[val]--;
    int newF = freq[val];
    if (newF > 0) {
        long long y = xorForFreq[newF];
        bit.add(newF, -y);
        xorForFreq[newF] ^= val;
        bit.add(newF, xorForFreq[newF]);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        for (int i = 0; i < n; i++) cin >> A[i];
        int q;
        cin >> q;
        vector<Query> queries(q);
        for (int i = 0; i < q; i++) {
            cin >> queries[i].l >> queries[i].r >> queries[i].x >> queries[i].y;
            queries[i].l--; queries[i].r--;
            queries[i].idx = i;
        }

        int block = sqrt(n);
        sort(queries.begin(), queries.end(), [&](Query &a, Query &b) {
            if (a.l / block != b.l / block) return a.l < b.l;
            return ((a.l / block) & 1) ? (a.r > b.r) : (a.r < b.r);
        });

        int maxFreq = n;
        Fenwick bit(maxFreq);

        freq.clear();
        xorForFreq.clear();

        vector<long long> ans(q);
        int curL = 0, curR = -1;

        for (auto &qr : queries) {
            int L = qr.l, R = qr.r;
            while (curL > L) add(A[--curL], bit, maxFreq);
            while (curR < R) add(A[++curR], bit, maxFreq);
            while (curL < L) removeVal(A[curL++], bit, maxFreq);
            while (curR > R) removeVal(A[curR--], bit, maxFreq);

            ans[qr.idx] = bit.rangeSum(qr.x, qr.y);
        }

        for (auto &x : ans) cout << x << "\n";
    }
    return 0;
}
